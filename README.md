CPU Scheduling Project

Background:
CPU scheduling is how processes get allotted to a CPU core to begin execution, and the Round-Robin algorithm is one of the ways it decides how to execute the various processes in the queue. A process enters the queue with a process ID, burst time, arrival time, and in my case a priority, and the CPU scheduler decides based on priority to add them to the ready queue for execution. Round-Robin gives each process a specific amount of time to execute, a time quantum. It then moves the process to the waiting queue, bringing the next one in through a context switch, and allowing that process the same amount of time to execute. The cycle continues until all processes are eventually completed and added to the finished queue.

Implementation:
My project implementation includes three classes: the Process class, which has the various attributes of a process, including processID, arrivalTime, initialBurstTime (which is used to get the waiting time), burstTime (for all other calculations), priority, completionTime, and processTime. It contains methods to get the turnaround time, which is the (completion time - arrival time), the wait time, which is (turnaround time - initial burst time), and the response time, which is (current time - arrival time). It also includes the methods runProcess, which updates the process’s burst time and process time based on the time quantum, and idlingProcess, which updates the process time based on the context switch time. The CPU class has the logic for the Round-Robin algorithm and updating all the necessary process details, including various attributes like the number of processes, the time it takes to perform a context switch, which I decided to make 2 ms, the number of context switches, and a timer which keeps track of the total execution time of the scheduler. It has 3 queues: the main Priority Queue to sort the processes initially by priority, and then the ready, waiting, and finished queues where the process goes to execute, wait, and terminate, respectively. The Round-Robin algorithm logic adds processes to the Ready queue for execution based on the user’s inputted time quantum. If it is not finished, a context switch is performed and it’s added to the waiting queue and the next process is queued for execution, and if it is finished, it’s added to the finished queue. The cycle continues until the finished queue is the same size as the initial number of processes, signaling that the loop is done. The code keeps track of the total time through the timer, which is updated with either the time quantum or the remaining process time, whichever is less, and the context switch time when the process is switched out for another, the number of context switches performed, and in the end prints the relevant statistics. It prints the total CPU time, the throughput which is calculated using (number of processes/total time), the utilization which is 1-(context switch time*context switches/total time) where idle time is represented by context switch time multiplied by the number of context switches performed, the average turnaround time which is the (completion time - arrival time)/(number of processes), and the average waiting time which is (turnaround time - initial burst time)/(number of processes). The Main class takes the user’s input to get the CSV file, which contains the processes in CSV format, parses the information into the relevant attributes for each Process object in the processes queue, and then takes the user’s desired integer as the time quantum for the scheduler.

Execution:

The program is executed by navigating to the directory that holds the 3 classes and the processes.csv file in the terminal, and entering “javac *.java” to compile the three classes, the next line is “java Main.java processes.csv _”, to execute the main class, and take the processes.csv file which contains the processes, and then to enter a time quantum for the scheduler to use
